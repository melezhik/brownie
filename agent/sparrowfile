#!raku

use Sparky::JobApi;

use Random::Names;

use JSON::Fast;

use URI::Encode;

class Pipeline

does Sparky::JobApi::Role

{

  method base-dir {
    "{%*ENV<HOME>}/.brownie"
  }
  
  method !agent-version {
    if "{%*ENV<HOME>}/.sparky/projects/agent/version".IO ~~ :f {
      return "{%*ENV<HOME>}/.sparky/projects/agent/version".IO.slurp().chomp;
    } else {
      "???"
    }
  }

  method stage-main {

    my $max-threads = Int(%*ENV<BRW_AGENT_MAX_THREADS> || 3);

    my $random-int = (0..9).flat.roll(8).join("");

    directory self.base-dir unless self.base-dir.IO ~~ :d;

    directory "{self.base-dir}/rakudos" unless "{self.base-dir}/rakudos".IO ~~ :d;

    my $agent-id = "{self.base-dir}/agent-id".IO ~~ :f 
    ?? "{self.base-dir}/agent-id".IO.slurp 
    !! $random-int;

    unless  "{self.base-dir}/agent-id".IO ~~ :f {
      "{self.base-dir}/agent-id".IO.spurt($random-int);
    }

    my $agent = ( %*ENV<BRW_AGENT_NAME_PREFIX> || Random::Names.new.docker-name ) ~ "-" ~ $agent-id;

    say "agent: $agent, max threads: $max-threads, version: {self!agent-version}, max threads: {Int(%*ENV<BRW_AGENT_MAX_THREADS> || 3)}";

    file-delete "tasks.tar";

    say "archiving tasks/ to tasks.tar";

    bash "tar cf {$*CWD}/tasks.tar -C tasks/ .";    

    my $orch-job = Sparky::JobApi.new(
      :api(config()<orchestrator-url>),
      :project<browny.queue>,
      :job-id($agent),
    );

    my $orch-feed = Sparky::JobApi.new(
      :api(config()<orchestrator-url>),
      :project<browny.feedback>,
      :job-id<done>,
    );

    my $i = 1;

    my $jobs-run-cnt = 0;
    
    while True {

      if ($i == 1) {

        # register agent / send agent heartbeat 
        # every 90 seconds

        my $orch-job2 = Sparky::JobApi.new(
          :api(config()<orchestrator-url>),
          :project("agent.{2.rand.Int + 1}.ping"),
        );

        task-run "tasks/jobs-cnt";
        $orch-job2.queue({
          description => "heartbeat from $agent, version: {self!agent-version}, max threads: {Int(%*ENV<BRW_AGENT_MAX_THREADS> || 3)}, jobs run cnt: $jobs-run-cnt",
          tags => %(
            agent => $agent,
            stage => "ping",
            jobs-run-cnt => $jobs-run-cnt,
            max-threads => $max-threads,
            agent-version => self!agent-version(),
          ),
        });
        # send local queue and running jobs
        # stat to o10r
        $orch-job2.put-file("q.data","q.data.txt");
        $orch-job2.put-file("r.data","r.data.txt");
        $i++;
      } elsif ($i == 9) {
         $i = 1;
      } else {
         $i++;
      }

      # update jobs counter
      # by taking into account
      # all active jobs
      # and all jobs in queue

      task-run "tasks/jobs-cnt";
      my $r-cnt = Int("r.cnt".IO.slurp.chomp);
      my $q-cnt = Int("q.cnt".IO.slurp.chomp);
      $jobs-run-cnt = $r-cnt + $q-cnt;

      my $q = $orch-job.get-stash();

      # syncronize information
      # about already proccesses
      # modules

      my $done = $orch-feed.get-stash();

      say "load requests from orchestrator queue";

      say "jobs-run-cnt: $jobs-run-cnt, max-threads: $max-threads";

      if $q {
        my $rakudo-version = $q<version>;
        if "{self.base-dir}/jobs/{$q<run-id>}".IO ~~ :d {
            say "skip job: {$q<run-id>}, already in agent queue";
        } elsif ($jobs-run-cnt >= $max-threads) {
          say "skip job: agent is busy"
        } else {
          if "/tmp/whateverable/rakudo-moar/{$rakudo-version}/bin/raku".IO ~~ :f {
            say "rakudo version $rakudo-version is already installed at /tmp/whateverable/rakudo-moar/{$rakudo-version}/bin/raku, skip installation";
          } else {
            if $q<source-code> or %*ENV<BRW_AGENT_CAP_INSTALL_FROM_SOURCE_FORCE> {
               task-run "tasks/install-rakudo-from-source", %(
                  version => $rakudo-version,
               ); 
            } else {
              module-run 'Rakudo::Install', %(
                :user<root>,
                :$rakudo-version,
                :!patch-profile,
              );
            }
          }
          say "///";
          say "run tests for job: {$q<run-id>}";
          say "///";
          my $j = Sparky::JobApi.new(
            project => "agent.job_{time}",
          );
          my @m-list;
          my %skip-list;
          if $done && $done<version> eq $rakudo-version {
            for $done<done><> -> $m {
              %skip-list{$m} = True;
            }
          }
          for $q<modules><> -> $m {
            if %skip-list{$m} {
              say "!!! skip module $m - already processed";
              next
            }
            push @m-list, $m;
          }
          if @m-list.elems {
            $j.put-stash(%(list => @m-list));
            $j.put-file("tasks.tar","tasks.tar");
            my %tags = %(
                rakudo-version => $rakudo-version,
                stage => "test",
                agent => $agent,
                zef_test_degree => %*ENV<ZEF_FETCH_DEGREE>,
                zef_fetch_degree => %*ENV<ZEF_TEST_DEGREE>,
                run-id => $q<run-id>,
            );
            %tags<zef_install_to> = True if %*ENV<ZEF_INSTALL_TO>;
            $j.queue({
              description => "job: {$q<run-id>}", 
              tags => %tags,
            });
          }
          mkdir "{self.base-dir}/jobs/{$q<run-id>}";
        }
      }
      sleep(5);
      say "<<< sleep for 5 seconds";
    }
  }

  method stage-test {

    my $agent = tags()<agent>;
    
    my $my = Sparky::JobApi.new( :mine );

    my $rakudo-version = tags()<rakudo-version>;

    bash "export PATH=/tmp/whateverable/rakudo-moar/{$rakudo-version}/bin/:/tmp/whateverable/rakudo-moar/{$rakudo-version}/share/perl6/site/bin:\$PATH && which zef > raku.env && zef --version >> raku.env && which raku >> raku.env && raku -V >> rakuenv.txt";

    $my.put-file("rakuenv.txt","rakuenv.txt");

    my $blob = $my.get-file("tasks.tar");

    directory "tasks";

    my $fh = open "tasks/tasks.tar", :w, :bin;
    $fh.write($blob);
    $fh.close;

    bash "tar -xf tasks.tar  && ls -l", %(
      cwd => "{$*CWD}/tasks",
      description => "unpack tasks.tar",
    );

    my @list = $my.get-stash()<list><>;

    say "===";

    say "list: \n", @list.join("\n");

    say "===";

    my %results;

    my $orch-job = Sparky::JobApi.new(
      :api(config()<orchestrator-url>),
      :project("job.{3.rand.Int + 1}.report"),
    );

    "list.txt".IO.spurt(@list.join("\n"));

    $my.put-file("list.txt","list.txt");

    my $status = True;

    for @list -> $m {
      
      my $test-ok = True; # module successfully passed tests
                          # could be chaged vi <testfail> section
      next if %results{$m};

      my $log = ( "log.txt".IO ~~ :f ) ?? "log.txt".IO.slurp  !! "no log data";

      my $s = task-run "tasks/run-test", %(
        module => $m,
        zef_install_to => tags()<zef_install_to>,
        zef_test_degree => tags()<zef_test_degree>,
        zef_fetch_degree => tags()<zef_fetch_degree>,
        rakudo_version => $rakudo-version,
      );
      if $s<inst> {
        say "modules installed ok during installation of module $m: ", $s<inst>.raku;
        for $s<inst><> -> $d {
          next if $d eq $m;
          %results{$d} = %(
            time => 0,
            log => "installed as deps of module $m\n\n$log",
            status => True,
            agent => $agent,
            parent => $m,
            check_method => "installdeps",
          );
          say "add $d to already processed list";
        }
      }
      if $s<fail> {
        say "modules tests fail during installation of module $m: ", $s<fail>.raku;
        for $s<fail><> -> $d {
          if $d eq $m {
            $test-ok = False; # mark module as not passing tests
            next
          }
          # re-run zef test to
          # collect test report
          if "{self.base-dir}/cache/{$rakudo-version}/modules/$d.report".IO ~~ :f {
            # read report from cache
            # for effecieny
            "report.txt".IO.spurt("{self.base-dir}/cache/{$rakudo-version}/modules/$d.report".IO.slurp);
          } else {
            task-run "tasks/zef-test", %(
              module => $d,
              zef_install_to => tags()<zef_install_to>,
              zef_test_degree => tags()<zef_test_degree>,
              zef_fetch_degree => tags()<zef_fetch_degree>,
              rakudo_version => $rakudo-version,
            );
            # save report into file cache for effecieny
            mkdir "{self.base-dir}/cache/{$rakudo-version}/modules";
            "{self.base-dir}/cache/{$rakudo-version}/modules/$d.report".IO.spurt("report.txt".IO.slurp);
          }
          %results{$d} = %(
            time => 0,
            log => "report.txt".IO.slurp,
            status => False,
            agent => $agent,
            testfail => True,
            parent => $m,
            check_method => "testfail",
          );
          say "add $d to already processed list";
        }
      }
      if $s<testok> {
        say "modules tests ok during installation of module $m: ", $s<inst>.raku;
        for $s<testok><> -> $d {
          next if $d eq $m;
          %results{$d} = %(
            time => 0,
            log => "tested ok as deps of module $m\n\n$log",
            status => True,
            agent => $agent,
            parent => $m,
            check_method => "testok",
          );
          say "add $d to already processed list";
        }
      }      
      next if %results{$m};
      say "add $m to already processed list";
      %results{$m}<agent> = $agent;
      %results{$m}<time> = 0;
      %results{$m}<log> = "";
      %results{$m}<testfail> = not $test-ok;
      %results{$m}<check_method> = "direct";
      if $s<success> == 1 {
        %results{$m}<status> = True
      } else {
        %results{$m}<status> = False;
        $status = False;
      }
      if "log.txt".IO ~~ :e {
        %results{$m}<log> = "log.txt".IO.slurp;
        $my.put-file("log.txt","{uri_encode_component($m)}.log.txt");
      }
    }
    
    if %results.keys.elems > 0 {
      $orch-job.put-stash(%results);
      $orch-job.put-file("rakuenv.txt","rakuenv.txt");
      $orch-job.queue({
        description => "job report from $agent", 
        tags => %(
          version => tags()<rakudo-version>,
          stage => "results",
        ),
      });
    }

    if %results.keys.elems > 0 {
      say "results:";
      say "===";
      for %results.kv -> $k, $v {
          say "$k ... {$v<status>}\t "
      }  
      say "===";
    }

    warn "some tests failed" unless $status;

  }

  method stage-ping {

    mkdir "{self.base-dir}/agents";
    mkdir "{self.base-dir}/agents-meta";
    
    "{self.base-dir}/agents/{tags()<agent>}".IO.unlink;

    "{self.base-dir}/agents/{tags()<agent>}".IO.spurt("");

    my $jobs-run-cnt = tags()<jobs-run-cnt> || 0;
    my $max-threads = tags()<max-threads> || 1;
    my $agent-version = tags()<agent-version> || "0.0.0";

    say "ping from agent: {tags()<agent>}, version: {$agent-version}, jobs-run-cnt: {$jobs-run-cnt}, max-threads: $max-threads";

    "{self.base-dir}/agents-meta/{tags()<agent>}.json".IO.spurt(
      to-json(
        %( 
          jobs-run-cnt => $jobs-run-cnt,
          max-threads => $max-threads,
          agent-version => $agent-version,
        ),
      )
    );

  }

  method stage-results {

    my $me = Sparky::JobApi.new( :mine );

    my $resutls = $me.get-stash();
    my $version = tags()<version>;
    my @list;
    my $status = True;
    for $resutls.kv -> $k, $v {
      if "{self.base-dir}/versions/$version/$k".IO ~~ :d {
         say "add module $k ... SKIP - already processed";
         next;
      }
      say "add module $k ... OK, status: {$v<status> ?? 'OK' !! 'FAIL' }, agent: {$v<agent>||'?'}, check_method: {$v< >}, parent: {$v<parent> || 'not set'} ";
      say "log:";
      say "===";
      mkdir "{self.base-dir}/versions/$version/$k";
      my $time = $v<time> || "?";
      if $v<status> {
        "{self.base-dir}/versions/$version/{$k}.OK".IO.spurt("");
        push @list, "$k ... \t OK \t {$time} sec";
        if $v<log> {
          say $v<log>;
        }
      } else {
        "{self.base-dir}/versions/$version/{$k}.FAIL".IO.spurt("");
        push @list, "$k ... \t FAIL \t {$time} sec";
        $status = False;
        if $v<log> {
          say $v<log>;
          "{self.base-dir}/versions/$version/{$k}.log".IO.spurt($v<log>);
          $me.put-file("{self.base-dir}/versions/$version/{$k}.log","{uri_encode_component($k)}.log");
        }
      }
      "{self.base-dir}/versions/$version/$k/meta.json".IO.spurt(
         to-json($v)
      );
      say "===";
    }

    "summary.txt".IO.spurt(@list.join("\n"));
    $me.put-file("summary.txt","summary.txt");

    say ">>>";
    warn "some tests failed" unless $status;

  }
}


Pipeline.new.run;
