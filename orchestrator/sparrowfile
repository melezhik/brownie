#!raku

use Sparky::JobApi;

use Ecosystem;

use JSON::Fast;

class Pipeline

does Sparky::JobApi::Role

{

  method base-dir {
    "{%*ENV<HOME>}/.brownie"
  }

  method !distribute (@_list,@agents,$sent-back) {

    my @sent;

    return @sent unless @_list.elems;

    return @sent unless @agents.elems;

    my $chunk = 0;

    say "distribute, sent-back: $sent-back";

    if @agents.elems > 0 && @_list.elems > 0 {

      if @_list.elems < @agents.elems {
          $chunk = 1;
          @agents = @agents[0 .. @_list.elems -1];
      } else {
        $chunk = Int(@_list.elems/@agents.elems);
        $chunk = 10 if $chunk > 10;
      }
    
      my $a = 0;

      say "agents used: {@agents.elems}";

      say "chunk: $chunk";

      for 1 .. @agents.elems -> $i {

        my @slice = @_list[$a .. $a + $chunk - 1];

        @slice = @slice.sort;

        say "push job to agent {@agents[$i-1]}";

        my $agents-queue = Sparky::JobApi.new(
          :project<browny.queue>,
          :job-id(@agents[$i-1]),
        );

        $agents-queue.put-stash(
          %( 
            version => "2025.10",
            agent => @agents[$i-1],
            modules => @slice,
            run-id => time, 
          )
        );

        say "slice: {@slice.raku}";
        $a = $a + $chunk;
        say "...";
        
        for @slice -> $s {
          push @sent, $s;
        }
      }
    }

    push @sent;

  }

  method stage-main {

    my @d;

    my $eco = Ecosystem.new;

    say "Testing 100 randome modules on the Raku Ecosystem River:";

    my $start_time = time;

    for $eco.river.map(*.key).sort(*, random => True).head(100) -> $d {
        push @d, $d;
        #say $d;
    }

    "list.txt".IO.spurt(@d.join("\n"));

    my $me = Sparky::JobApi.new(:mine);

    $me.put-file("list.txt","list.txt");
    
    my $j = 0;

    my %sent;

    my @agents;

    while (True) {

      my @_list = [];
      
      my $alr-comp = 0;

      # recalc stat and prepare new chunk of tests
      # to process
      my $sent-back = 0;
      for @d -> $l {
        if "{self.base-dir}/versions/2025.10/{$l}.OK".IO ~~ :f  ||
           "{self.base-dir}/versions/2025.10/{$l}.FAIL".IO ~~ :f  {
              # module is already completed
              $alr-comp++;
              %sent{$l}:delete;
              next;
        }
        if %sent{$l} {
          my $delta = Int(now - %sent{$l});
          if $delta > 600*3 {
              #say "we have not heard anyting from $l last 30 minutes, return it back to orch queue";
              %sent{$l}:delete;
              $sent-back++;
              push @_list, %( module => $l, send-back => True );
          } else {
            # module is already send to some agent
            # and have processing time less then
            # 30 minutes
            # skip it
            next
          }
        } else {
          push @_list, %( module => $l, send-back => False );
        }
      }

      my $els = Int(time - $start_time);
      my $elh;

      if $els < 60 {
         $elh = "<1m";
      } elsif $els < 60*60 {
         $elh = sprintf("%.2dm", Int($els/60));
      } elsif $els < 60*60*24 {
         $elh = sprintf("%.3dh", Int($els/(60*60)));
      }
   
      say "||| TESTS STAT: time: {$elh} | finished tests: {$alr-comp} | tests in progress: {%sent.keys.elems} | tests total: {@d.elems} | current queue: {@_list.elems} | send back: $sent-back | agents cnt: {@agents.elems}";

      #@_list.=pick(@_list);

      if $alr-comp == @d.elems {
        last;
      }
      
      say "look for available agents ...";

      @agents = [];

      if "{self.base-dir}/agents".IO ~~ :d { 
        
        for dir("{self.base-dir}/agents") -> $ag {

          my $age = Int(now - $ag.created.DateTime);

          if $age <= 360 { # only use agents with 6 minutes ago at least heartbeat
            my $q-cnt = 1000;
            if "{self.base-dir}/agents-meta/{$ag.basename}.json" ~~ :f {
              my %meta = from-json("{self.base-dir}/agents-meta/{$ag.basename}.json".IO.slurp);
              $q-cnt = %meta<q-cnt>;
            }
            say "agent {$ag.basename} heartbeat OK - [$age] seconds | q-cnt - {$q-cnt}";
            push @agents, %( name => $ag.basename, q-cnt => $q-cnt);
          } else {
            say "remove agent {$ag.basename} from rotation, BAD heartbit -  $age seconds";
            $ag.unlink; 
          }
        };
      }

      say "";

      say "{@agents.elems} online agents found";
        
      # distibute jobs on all agents with c-qnt > 0
      my @s = self!distribute(
        @_list.grep({$_<send-back> == False}).map({$_<module>}),
        @agents.grep({ $_<q-cnt> > 0}).map({$_<name>}),
        False
      );

      for @s -> $s {
        %sent{$s} = now;
      };

      # re-distibute stuck jobs on fresh agents
      @s = self!distribute(
        @_list.grep({$_<send-back> == True}).map({$_<module>}),
        @agents.grep({ $_<q-cnt> == 0}).map({$_<name>}),
        True
      );

      for @s -> $s {
        %sent{$s} = now;
      };

      #say "<<< sleep for 30 seconds";

      sleep(120);

      $j++;
      
      last if $j > 10000;
      
    }

    say "done";

    say "summary";
    my $summary = "";

    for @d -> $m {

      my $status = "?";

      $status = "OK" if "{self.base-dir}/versions/2025.10/{$m}.OK".IO ~~ :f;
      $status = "FAIL" if "{self.base-dir}/versions/2025.10/{$m}.FAIL".IO ~~ :f;

      say "$m ... \t $status";

      $summary ~= "$m ... \t $status\n";
     
    }

    "summary.txt".IO.spurt($summary);
    

    for @d -> $m {
      if "{self.base-dir}/versions/2025.10/{$m}.log".IO ~~ :f {
        $me.put-file("{self.base-dir}/versions/2025.10/{$m}.log","$m.log");
      }
    }

    $me.put-file("summary.txt","summary.txt");

  }
}  

Pipeline.new.run;
