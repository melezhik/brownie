#!raku

use Sparky::JobApi;

use Ecosystem;

use JSON::Fast;

class Pipeline

does Sparky::JobApi::Role

{

  method base-dir {
    "{%*ENV<HOME>}/.brownie"
  }

  method !distribute (@_list,@agents,$sent-back) {

    my @sent;

    return @sent unless @_list.elems;

    return @sent unless @agents.elems;

    my $chunk = 0;

    say "distribute, redistribution: $sent-back";

    if @agents.elems > 0 && @_list.elems > 0 {

      if @_list.elems < @agents.elems {
          $chunk = 1;
          @agents = @agents[0 .. @_list.elems -1];
      } else {
        $chunk = Int(@_list.elems/@agents.elems);
        $chunk = 10 if $chunk > 10;
      }
    
      my $a = 0;

      say "agents used: {@agents.elems}";

      say "chunk: $chunk";

      for 1 .. @agents.elems -> $i {

        my @slice = @_list[$a .. $a + $chunk - 1];

        @slice = @slice.sort;

        say "push job to agent {@agents[$i-1]}";

        my $agents-queue = Sparky::JobApi.new(
          :project<browny.queue>,
          :job-id(@agents[$i-1]),
        );

        $agents-queue.put-stash(
          %( 
            version => "2025.10",
            agent => @agents[$i-1],
            modules => @slice,
            run-id => time, 
          )
        );

        say "slice: {@slice.raku}";
        $a = $a + $chunk;
        say "...";
        
        for @slice -> $s {
          push @sent, $s;
        }
      }
    }

    push @sent;

  }

  method stage-main {

    my @d;

    my $eco = Ecosystem.new;

    say "Testing 100 randome modules on the Raku Ecosystem River:";

    my $start_time = time;

    for $eco.river.map(*.key).sort.head(100) -> $d {
        push @d, $d;
        #say $d;
    }

    "list.txt".IO.spurt(@d.join("\n"));

    my $me = Sparky::JobApi.new(:mine);

    $me.put-file("list.txt","list.txt");
    
    my $j = 0;

    my %sent;

    while (True) {

      my @_list = []; # tests to distribute
      
      my $done = 0; # finished tests

      my @agents; # online agents

      say "look for available agents ...";

      if "{self.base-dir}/agents".IO ~~ :d { 
        
        for dir("{self.base-dir}/agents") -> $ag {

          my $age = Int(now - $ag.created.DateTime);

          if $age <= 360 { # only use agents with 6 minutes ago at least heartbeat
            my $q-cnt = 1000;
            if "{self.base-dir}/agents-meta/{$ag.basename}.json".IO ~~ :f {
              my %meta = from-json("{self.base-dir}/agents-meta/{$ag.basename}.json".IO.slurp);
              $q-cnt = %meta<q-cnt>;
            }
            say "agent {$ag.basename} heartbeat OK - [$age] seconds | q-cnt - [{$q-cnt}]";
            push @agents, %( name => $ag.basename, q-cnt => $q-cnt);
          } else {
            say "remove agent {$ag.basename} from rotation, BAD heartbit -  $age seconds";
            $ag.unlink; 
          }
        };
      }

      say "xxx";

      say "{@agents.elems} online agents found";
      
      # prepare tests for 
      # distribution

      for @d -> $l {
        if "{self.base-dir}/versions/2025.10/{$l}.OK".IO ~~ :f  ||
           "{self.base-dir}/versions/2025.10/{$l}.FAIL".IO ~~ :f  {
              # module is already completed
              $done++;
              next;
        }
        if %sent{$l} {
          push @_list, %( module => $l, send-back => False );
        }
      }
   
      #@_list.=pick(@_list);

      if $done == @d.elems {
        last;
      }
      
      # distibute tests on agents with none zero queue
      my @s = self!distribute(
        @_list.grep({$_<send-back> == False}).sort({$_<q-cnt>}).map({$_<module>}),
        @agents.grep({ $_<q-cnt> > 0}).map({$_<name>}),
        False
      );
      my @rs;
      if @s.elems {
        # re-distibute old tests on agents with zero queue
        @rs = self!distribute(
          @_list.grep({$_<send-back> == True}).map({$_<module>}),
          @agents.grep({ $_<q-cnt> == 0}).map({$_<name>}),
          True
        );
        # mark distributed tests
        for @rs -> $s {
          %sent{$s} = now;
        };
      }
      # mark distributed tests
      for @s -> $s {
        %sent{$s} = now;
      };

      my $els = Int(time - $start_time);

      my $elh;

      if $els < 60 {
         $elh = "<1m";
      } elsif $els < 60*60 {
         $elh = sprintf("%.2dm", Int($els/60));
      } elsif $els < 60*60*24 {
         $elh = sprintf("%.3dh", Int($els/(60*60)));
      }

      say "||| TESTS STAT: time: {$elh} | finished tests: {$done} | tests total: {@d.elems} | current queue: {@rs.elems} + {@s.elems} | redistributed: {@rs.elems} | agents cnt: {@agents.elems}";

      sleep(80);

      $j++;
      
      last if $j > 10000;
      
    }

    say "done";

    say "summary";

    my $summary = "";

    for @d -> $m {

      my $status = "?";

      $status = "OK" if "{self.base-dir}/versions/2025.10/{$m}.OK".IO ~~ :f;
      $status = "FAIL" if "{self.base-dir}/versions/2025.10/{$m}.FAIL".IO ~~ :f;

      say "$m ... \t $status";

      $summary ~= "$m ... \t $status\n";
     
    }

    "summary.txt".IO.spurt($summary);
    

    for @d -> $m {
      if "{self.base-dir}/versions/2025.10/{$m}.log".IO ~~ :f {
        $me.put-file("{self.base-dir}/versions/2025.10/{$m}.log","$m.log");
      }
    }

    $me.put-file("summary.txt","summary.txt");

  }
}  

Pipeline.new.run;
